<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>弹簧-质量-阻尼系统演示</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <!-- 添加Chart.js注释插件 -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.0.0/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.8.0/lib/browser/math.min.js"></script>
    <!-- 添加KaTeX支持 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <style>
        body {
            font-family: "Microsoft YaHei", Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        .panel {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fff;
        }
        .system-animation {
            width: 100%;
            height: 200px;
            border: 1px solid #ccc;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
            background-color: #f9f9f9;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            width: 150px;
        }
        .value-display {
            width: 40px;
            text-align: center;
        }
        button {
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #2980b9;
        }
        .equation-box {
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-family: "Cambria Math", Georgia, serif;
            margin: 10px 0;
            overflow-x: auto;
        }
        .plot-container {
            height: 250px;
            margin: 15px 0;
        }
        .spring {
            position: absolute;
            height: 20px;
            background-color: #7f8c8d;
            bottom: 100px;
            left: 50px;
            width: 80px;
        }
        .mass {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #e74c3c;
            bottom: 90px;
            left: 130px;
            border-radius: 5px;
        }
        .damper {
            position: absolute;
            height: 60px;
            width: 10px;
            background-color: #3498db;
            bottom: 70px;
            left: 200px;
        }
        .ground {
            position: absolute;
            height: 10px;
            background-color: #2c3e50;
            bottom: 70px;
            left: 0;
            width: 100%;
        }
        .force-arrow {
            position: absolute;
            width: 40px;
            height: 10px;
            background-color: #f39c12;
            bottom: 105px;
            left: 180px;
        }
        .tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        .tab.active {
            border-color: #ddd;
            background-color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .pole-zero-plot {
            width: 100%;
            height: 250px;
            position: relative;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            margin-top: 10px;
        }
        .pole {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #e74c3c;
            transform: translate(-50%, -50%);
        }
        .zero {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid #3498db;
            background-color: transparent;
            transform: translate(-50%, -50%);
        }
        .s-plane-axes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .x-axis, .y-axis {
            position: absolute;
            background-color: #333;
        }
        .x-axis {
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
        }
        .y-axis {
            width: 1px;
            height: 100%;
            top: 0;
            left: 50%;
        }
        .pole-label {
            position: absolute;
            font-size: 12px;
            color: #e74c3c;
            transform: translate(0, -10%);
            white-space: nowrap;
        }
        .axis-label {
            position: absolute;
            font-size: 12px;
            color: #333;
        }
        /* 添加LaTeX公式样式 */
        .latex-formula {
            text-align: center;
            margin: 10px 0;
        }
        /* PID控制器样式 */
        .pid-panel {
            border-top: 1px solid #ddd;
            margin-top: 20px;
            padding-top: 20px;
        }
        .pid-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        .pid-toggle {
            margin: 10px 0;
        }
        .pid-toggle label {
            margin-right: 10px;
        }
        .setpoint-control {
            margin-top: 10px;
        }
        .reference-line {
            position: absolute;
            width: 100%;
            height: 1px;
            background-color: #2ecc71;
            z-index: 5;
        }
        .pid-info {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        /* 传递函数区域样式 */
        .pid-transfer-functions {
            margin-top: 15px;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .pid-transfer-functions h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #3498db;
            font-size: 1em;
        }
        .pid-transfer-functions .equation-box {
            margin-bottom: 8px;
            background-color: white;
            border-left: 3px solid #3498db;
            padding: 5px;
        }
        /* 添加并排显示样式 */
        .transfer-functions-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        .transfer-function-column {
            flex: 1;
        }
        .transfer-function-column .equation-box {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .pid-transfer-functions .equation-box:last-child {
            margin-bottom: 0;
        }
        /* 添加标签以区分不同的传递函数 */
        .transfer-function-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 3px;
            font-weight: bold;
        }
        /* 添加 KaTeX 公式缩放 */
        .compact-formula .katex {
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>弹簧-质量-阻尼系统动态演示</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="mass">质量 (m)</label>
                <div class="slider-container">
                    <input type="range" id="mass" min="0.1" max="5" step="0.1" value="1">
                    <span id="mass-value" class="value-display">1 kg</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="damping">阻尼系数 (c)</label>
                <div class="slider-container">
                    <input type="range" id="damping" min="0" max="10" step="0.1" value="2">
                    <span id="damping-value" class="value-display">2 N·s/m</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="spring">弹簧刚度 (k)</label>
                <div class="slider-container">
                    <input type="range" id="spring" min="1" max="30" step="0.1" value="10">
                    <span id="spring-value" class="value-display">10 N/m</span>
                </div>
            </div>
            
            <button id="reset-button">重置参数</button>
            <button id="step-input">施加阶跃输入</button>
        </div>
        
        <!-- 添加PID控制器部分 -->
        <div class="pid-panel">
            <h2>PID控制器</h2>
            
            <div class="pid-toggle">
                <label for="pid-enable">启用PID控制:</label>
                <input type="checkbox" id="pid-enable">
            </div>
            
            <div class="pid-controls">
                <div class="control-group">
                    <label for="kp">比例增益 (Kp)</label>
                    <div class="slider-container">
                        <input type="range" id="kp" min="0" max="50" step="0.1" value="10">
                        <span id="kp-value" class="value-display">10</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="ki">积分增益 (Ki)</label>
                    <div class="slider-container">
                        <input type="range" id="ki" min="0" max="10" step="0.1" value="0.5">
                        <span id="ki-value" class="value-display">0.5</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="kd">微分增益 (Kd)</label>
                    <div class="slider-container">
                        <input type="range" id="kd" min="0" max="10" step="0.1" value="2">
                        <span id="kd-value" class="value-display">2</span>
                    </div>
                </div>
            </div>
            
            <div class="setpoint-control">
                <div class="control-group">
                    <label for="setpoint">设定值 (r)</label>
                    <div class="slider-container">
                        <input type="range" id="setpoint" min="0" max="2" step="0.1" value="1">
                        <span id="setpoint-value" class="value-display">1</span>
                    </div>
                </div>
            </div>
            
            <!-- 添加传递函数显示 -->
            <div class="pid-transfer-functions">
                <h3>传递函数</h3>
                <div class="transfer-functions-row">
                    <div class="transfer-function-column">
                        <div class="transfer-function-label">PID控制器:</div>
                        <div class="equation-box latex-formula compact-formula" id="pid-transfer-function">
                            \[C(s) = K_p + \frac{K_i}{s} + K_d s\]
                        </div>
                    </div>
                    <div class="transfer-function-column">
                        <div class="transfer-function-label">闭环传递函数:</div>
                        <div class="equation-box latex-formula compact-formula" id="closed-loop-simplified">
                            <!-- 这里会由JavaScript动态更新 -->
                        </div>
                        <!-- 添加一个辅助显示区域，在PID启用时显示 -->
                        <div class="equation-box latex-formula compact-formula" id="pid-closed-loop" style="display: none;">
                            \[T(s) = \frac{K_d s^2 + K_p s + K_i}{m s^3 + (c+K_d)s^2 + (k+K_p)s + K_i}\]
                        </div>
                        <!-- 非PID状态显示区域 -->
                        <div class="equation-box latex-formula compact-formula" id="non-pid-closed-loop" style="display: none;">
                            \[T(s) = \frac{1}{m s^2 + c s + k}\]
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="pid-info" id="pid-info">
                <!-- 默认文本已被删除 -->
            </div>
        </div>
        
        <div class="flex-container">
            <div class="panel">
                <h2>物理系统</h2>
                <div class="system-animation" id="animation-container">
                    <div class="ground"></div>
                    <div class="spring" id="spring-element"></div>
                    <div class="mass" id="mass-element"></div>
                    <div class="damper" id="damper-element"></div>
                    <div class="force-arrow" id="force-arrow" style="display: none;"></div>
                </div>
                
                <h3>微分方程（时域表示）</h3>
                <div class="equation-box latex-formula" id="differential-equation">
                    m\ddot{x}(t) + c\dot{x}(t) + kx(t) = F(t)
                </div>
                
                <h3>传递函数（频域表示）</h3>
                <div class="equation-box latex-formula" id="transfer-function">
                    G(s) = \frac{1}{ms^2 + cs + k}
                </div>
            </div>
            
            <div class="panel">
                <div class="tabs">
                    <div class="tab active" data-tab="time-domain">时域分析</div>
                    <div class="tab" data-tab="frequency-domain">频域分析</div>
                    <div class="tab" data-tab="s-plane">s平面分析</div>
                </div>
                
                <div class="tab-content active" id="time-domain">
                    <h3>阶跃响应</h3>
                    <div class="plot-container">
                        <canvas id="time-response-chart"></canvas>
                    </div>
                    <p>
                        时域分析直接展示系统对输入的响应随时间的变化。
                        从阶跃响应中可以观察到：
                    </p>
                    <ul>
                        <li>上升时间：系统响应初始增长速度</li>
                        <li>峰值时间：达到第一个峰值的时间</li>
                        <li>超调量：峰值超过稳态值的百分比</li>
                        <li>稳定时间：响应进入稳态范围所需的时间</li>
                    </ul>
                </div>
                
                <div class="tab-content" id="frequency-domain">
                    <h3>Bode图</h3>
                    <div class="plot-container" style="height: 400px;">
                        <canvas id="bode-combined-chart"></canvas>
                    </div>
                    <p>
                        频域分析展示了系统在不同频率下的响应特性：
                    </p>
                    <ul>
                        <li>幅频特性：表示系统在各频率下的增益</li>
                        <li>相频特性：表示系统在各频率下的相位滞后</li>
                        <li>共振峰：表示系统的共振频率，与阻尼比相关</li>
                        <li>截止频率：系统幅值下降到-3dB的频率，表示系统带宽</li>
                        <li>相位富裕度：增益为0dB时的相位与-180°之间的差值</li>
                    </ul>
                </div>
                
                <div class="tab-content" id="s-plane">
                    <h3>极点零点分析</h3>
                    <div class="pole-zero-plot" id="pole-zero-container">
                        <div class="s-plane-axes">
                            <div class="x-axis"></div>
                            <div class="y-axis"></div>
                        </div>
                    </div>
                    <div class="equation-box latex-formula" id="characteristic-equation">
                        特征方程：ms^2 + cs + k = 0
                    </div>
                    <p>
                        s平面分析揭示了系统的稳定性和动态特性：
                    </p>
                    <ul>
                        <li>极点位于左半平面 → 系统稳定</li>
                        <li>极点位于虚轴 → 等幅振荡</li>
                        <li>极点位于右半平面 → 系统不稳定</li>
                        <li>极点到原点的距离 → 系统响应速度</li>
                        <li>极点与实轴的夹角 → 系统振荡频率</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>时域与频域的转换关系</h2>
            <p>
                拉普拉斯变换将时域中的微分方程转换为频域中的代数方程，极大地简化了分析过程。
                对于弹簧-质量-阻尼系统，其转换关系为：
            </p>
            <div class="equation-box">
                <div class="latex-formula">
                    \[m\ddot{x}(t) + c\dot{x}(t) + kx(t) = F(t)\]
                </div>
                <div style="text-align: center;">⬇️ 拉普拉斯变换 ⬇️</div>
                <div class="latex-formula">
                    \[ms^2X(s) + csX(s) + kX(s) = F(s)\]
                </div>
                <div style="text-align: center;">⬇️ 整理得到传递函数 ⬇️</div>
                <div class="latex-formula">
                    \[G(s) = \frac{X(s)}{F(s)} = \frac{1}{ms^2 + cs + k}\]
                </div>
            </div>
            <p>
                系统特性参数与传递函数的关系：
            </p>
            <ul>
                <li><strong>自然频率 ωn</strong> = \(\sqrt{\frac{k}{m}}\)：表示无阻尼时系统的振荡频率</li>
                <li><strong>阻尼比 ζ</strong> = \(\frac{c}{2\sqrt{km}}\)：描述系统阻尼程度</li>
                <li><strong>阻尼振荡频率 ωd</strong> = \(\omega_n\sqrt{1-\zeta^2}\)：实际振荡频率</li>
            </ul>
            <p>
                当调整系统参数时，可以观察到：
            </p>
            <ul>
                <li>增加质量(m)：降低自然频率，系统响应变慢</li>
                <li>增加阻尼(c)：减小振荡，极点向实轴移动</li>
                <li>增加刚度(k)：提高自然频率，Bode图右移</li>
            </ul>
        </div>
    </div>

    <script>
        // 系统参数
        let mass = 1;           // 质量 (kg)
        let damping = 2;        // 阻尼系数 (N·s/m)
        let springK = 10;       // 弹簧刚度 (N/m)
        let stepInput = false;  // 阶跃输入状态
        
        // PID控制器参数
        let pidEnabled = false; // PID控制器开关
        let kp = 10;            // 比例增益
        let ki = 0.5;           // 积分增益
        let kd = 2;             // 微分增益
        let setpoint = 1;       // 设定值
        
        // 获取UI元素
        const massSlider = document.getElementById('mass');
        const dampingSlider = document.getElementById('damping');
        const springSlider = document.getElementById('spring');
        const massValue = document.getElementById('mass-value');
        const dampingValue = document.getElementById('damping-value');
        const springValue = document.getElementById('spring-value');
        const resetButton = document.getElementById('reset-button');
        const stepInputButton = document.getElementById('step-input');
        const differentialEquation = document.getElementById('differential-equation');
        const transferFunction = document.getElementById('transfer-function');
        const characteristicEquation = document.getElementById('characteristic-equation');
        const massElement = document.getElementById('mass-element');
        const springElement = document.getElementById('spring-element');
        const damperElement = document.getElementById('damper-element');
        const forceArrow = document.getElementById('force-arrow');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // PID控制器UI元素
        const pidEnableCheckbox = document.getElementById('pid-enable');
        const kpSlider = document.getElementById('kp');
        const kiSlider = document.getElementById('ki');
        const kdSlider = document.getElementById('kd');
        const kpValue = document.getElementById('kp-value');
        const kiValue = document.getElementById('ki-value');
        const kdValue = document.getElementById('kd-value');
        const setpointSlider = document.getElementById('setpoint');
        const setpointValue = document.getElementById('setpoint-value');
        const pidInfo = document.getElementById('pid-info');
        
        // 图表上下文
        let timeResponseChart;
        let bodeCombinedChart;
        
        // 全局变量定义
        let velocity = 0;
        let lastError = 0;
        let previousPosition = 0;
        let integralSum = 0; // 新增积分累加变量
        let lastTime = 0; // 用于计算实际时间差
        
        // 初始化图表
        function initCharts() {
            // 无需手动注册插件，改为在HTML头部加载特定版本
            
            // 时域响应图表
            const timeCtx = document.getElementById('time-response-chart').getContext('2d');
            timeResponseChart = new Chart(timeCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '位移 x(t)',
                        data: [],
                        borderColor: '#e74c3c',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.2,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        annotation: {
                            annotations: {}
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '时间 (秒)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return Number(value).toFixed(1);
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '位移 (米)'
                            }
                        }
                    }
                }
            });
            
            // 合并的Bode图
            const bodeCombinedCtx = document.getElementById('bode-combined-chart').getContext('2d');
            bodeCombinedChart = new Chart(bodeCombinedCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: '幅值 (dB)',
                            data: [],
                            borderColor: '#3498db',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y-magnitude'
                        },
                        {
                            label: '相位 (度)',
                            data: [],
                            borderColor: '#2ecc71',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y-phase'
                        },
                        {
                            label: '0 dB参考线',
                            data: [],
                            borderColor: 'rgba(231, 76, 60, 0.5)',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y-magnitude'
                        },
                        {
                            label: '-180°参考线',
                            data: [],
                            borderColor: 'rgba(231, 76, 60, 0.5)',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y-phase'
                        }
                        // 移除固定的-3dB水平线，改为使用Chart.js注释插件添加垂直线
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 500  // 加速动画
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    stacked: false,
                    scales: {
                        x: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: '频率 (rad/s)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return Number(value).toFixed(1);
                                }
                            }
                        },
                        'y-magnitude': {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: '幅值 (dB)'
                            },
                            grid: {
                                drawOnChartArea: true,
                            },
                        },
                        'y-phase': {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: '相位 (度)'
                            },
                            min: -180,
                            max: 0,
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                filter: function(item, chart) {
                                    // 隐藏参考线的图例
                                    return !item.text.includes('参考线');
                                }
                            }
                        },
                        // 启用注释插件
                        annotation: {
                            annotations: {}
                        }
                    }
                }
            });
        }
        
        // 初始化KaTeX渲染
        function renderLatexFormulas() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ],
                throwOnError: false
            });
        }
        
        // 更新数学表达式
        function updateEquations() {
            differentialEquation.innerHTML = `\\[${mass}\\ddot{x}(t) + ${damping}\\dot{x}(t) + ${springK}x(t) = F(t)\\]`;
            transferFunction.innerHTML = `\\[G(s) = \\frac{1}{${mass}s^2 + ${damping}s + ${springK}}\\]`;
            characteristicEquation.innerHTML = `特征方程：\\[${mass}s^2 + ${damping}s + ${springK} = 0\\]`;
            
            // 重新渲染LaTeX
            renderMathInElement(differentialEquation);
            renderMathInElement(transferFunction);
            renderMathInElement(characteristicEquation);
        }
        
        // 计算PID控制下的系统响应
        function calculatePIDResponse() {
            try {
                const timePoints = 100; // 减少数据点数量
                const maxTime = 10;
                const dt = maxTime / timePoints;
                
                const timeData = [];
                const responseData = [];
                const controlData = []; // 控制信号
                const errorData = [];   // 误差信号
                
                // 系统状态变量
                let position = 0;
                let velocity = 0;
                let integral = 0;
                let lastError = 0;
                
                for (let i = 0; i < timePoints; i++) {
                    const t = i * dt;
                    timeData.push(Number(t.toFixed(2)));
                    
                    // 计算误差
                    const error = setpoint - position;
                    errorData.push(error);
                    
                    // PID控制
                    integral += error * dt;
                    const derivative = (error - lastError) / dt;
                    lastError = error;
                    
                    // 计算控制信号
                    const controlSignal = kp * error + ki * integral + kd * derivative;
                    controlData.push(controlSignal);
                    
                    // 系统动力学方程: m*a + c*v + k*x = u
                    // a = (u - c*v - k*x) / m
                    const acceleration = (controlSignal - damping * velocity - springK * position) / mass;
                    
                    // 更新速度和位置（欧拉积分）
                    velocity += acceleration * dt;
                    position += velocity * dt;
                    
                    responseData.push(position);
                }
                
                return { timeData, responseData, controlData, errorData };
            } catch (e) {
                console.error("计算PID响应时出错:", e);
                // 返回空数据防止崩溃
                return { 
                    timeData: Array(100).fill(0).map((_, i) => i/10), 
                    responseData: Array(100).fill(0),
                    controlData: Array(100).fill(0),
                    errorData: Array(100).fill(0)
                };
            }
        }
        
        // 计算阶跃响应，添加PID控制支持
        function calculateStepResponse() {
            try {
                if (pidEnabled) {
                    return calculatePIDResponse();
                }
                
                const timePoints = 100; // 减少数据点数量
                const maxTime = 10;
                const dt = maxTime / timePoints;
                
                // 计算系统参数
                const wn = Math.sqrt(springK / mass);  // 自然频率
                const zeta = damping / (2 * Math.sqrt(mass * springK));  // 阻尼比
                
                const timeData = [];
                const responseData = [];
                
                for (let i = 0; i < timePoints; i++) {
                    const t = i * dt;
                    timeData.push(Number(t.toFixed(2))); // 保留两位小数，避免浮点精度问题
                    
                    let x;
                    if (zeta < 1) {  // 欠阻尼
                        const wd = wn * Math.sqrt(1 - zeta * zeta);  // 阻尼振荡频率
                        x = 1 - (Math.exp(-zeta * wn * t) / Math.sqrt(1 - zeta * zeta)) * 
                            Math.sin(wd * t + Math.atan(Math.sqrt(1 - zeta * zeta) / zeta));
                    } else if (zeta === 1) {  // 临界阻尼
                        x = 1 - Math.exp(-wn * t) * (1 + wn * t);
                    } else {  // 过阻尼
                        const p1 = -wn * (zeta + Math.sqrt(zeta * zeta - 1));
                        const p2 = -wn * (zeta - Math.sqrt(zeta * zeta - 1));
                        x = 1 + (p2 * Math.exp(p1 * t) - p1 * Math.exp(p2 * t)) / (p2 - p1);
                    }
                    
                    responseData.push(x);
                }
                
                return { timeData, responseData };
            } catch (e) {
                console.error("计算阶跃响应时出错:", e);
                // 返回空数据防止崩溃
                return { 
                    timeData: Array(100).fill(0).map((_, i) => i/10), 
                    responseData: Array(100).fill(0) 
                };
            }
        }
        
        // 计算Bode图数据
        function calculateBodeData() {
            const frequencyPoints = 100;
            const minFreq = 0.1;
            const maxFreq = 100;
            const logStep = Math.pow(maxFreq / minFreq, 1 / (frequencyPoints - 1));
            
            const freqData = [];
            const magData = [];
            const phaseData = [];
            
            for (let i = 0; i < frequencyPoints; i++) {
                const w = minFreq * Math.pow(logStep, i);
                freqData.push(w);
                
                // 计算传递函数在s = jw处的值
                const numerator = 1;
                const denominator = math.complex(springK - mass * w * w, damping * w);
                const G = math.divide(numerator, denominator);
                
                // 转换为dB和相位
                const magdB = 20 * Math.log10(math.abs(G));
                const phase = math.arg(G) * 180 / Math.PI;
                
                magData.push(magdB);
                phaseData.push(phase);
            }
            
            return { freqData, magData, phaseData };
        }
        
        // 计算系统极点
        function calculatePoles() {
            // 特征方程：ms^2 + cs + k = 0
            const wn = Math.sqrt(springK / mass);  // 自然频率
            const zeta = damping / (2 * Math.sqrt(mass * springK));  // 阻尼比
            
            // 极点位置
            if (zeta < 1) {  // 欠阻尼：复数共轭极点
                const realPart = -zeta * wn;
                const imagPart = wn * Math.sqrt(1 - zeta * zeta);
                return [
                    { real: realPart, imag: imagPart },
                    { real: realPart, imag: -imagPart }
                ];
            } else if (zeta === 1) {  // 临界阻尼：重极点
                return [
                    { real: -wn, imag: 0 },
                    { real: -wn, imag: 0 }
                ];
            } else {  // 过阻尼：两个实极点
                const sqrtTerm = Math.sqrt(zeta * zeta - 1);
                return [
                    { real: -wn * (zeta + sqrtTerm), imag: 0 },
                    { real: -wn * (zeta - sqrtTerm), imag: 0 }
                ];
            }
        }
        
        // 更新s平面极点图
        function updatePolePlot() {
            const container = document.getElementById('pole-zero-container');
            container.innerHTML = ''; // 清空容器
            
            // 添加坐标轴
            const axesContainer = document.createElement('div');
            axesContainer.className = 's-plane-axes';
            
            const xAxis = document.createElement('div');
            xAxis.className = 'x-axis';
            axesContainer.appendChild(xAxis);
            
            const yAxis = document.createElement('div');
            yAxis.className = 'y-axis';
            axesContainer.appendChild(yAxis);
            
            container.appendChild(axesContainer);
            
            // 添加轴标签
            const xLabel = document.createElement('div');
            xLabel.className = 'axis-label';
            xLabel.textContent = '实轴';
            xLabel.style.right = '10px';
            xLabel.style.top = '50%';
            xLabel.style.transform = 'translateY(-50%)';
            container.appendChild(xLabel);
            
            const yLabel = document.createElement('div');
            yLabel.className = 'axis-label';
            yLabel.textContent = '虚轴';
            yLabel.style.left = '50%';
            yLabel.style.top = '10px';
            yLabel.style.transform = 'translateX(-50%)';
            container.appendChild(yLabel);
            
            // 计算系统极点
            let poles;
            
            if (pidEnabled) {
                // 计算带PID控制器的闭环极点
                // 使用简化闭环特征方程：ms³ + (c+Kd)s² + (k+Kp)s + Ki = 0
                // 这部分需要求解三次方程，可以使用一些简化的数值方法
                
                // 这里使用一个简化的近似方法，仅用于演示
                // 在实际应用中，应使用更准确的根求解方法
                const a = mass;
                const b = damping + kd;
                const c = springK + kp;
                const d = ki;
                
                // 使用一个简单的数值方法查找复平面上的极点
                // 这里仅作为演示，实际应使用专业的根求解算法
                poles = [];
                
                // 寻找实数根（简化版）
                if (d === 0) {
                    poles.push({ real: 0, imag: 0 });
                    
                    // 二次方程：as² + bs + c = 0
                    const discriminant = b*b - 4*a*c;
                    if (discriminant >= 0) {
                        const sqrtDisc = Math.sqrt(discriminant);
                        poles.push({ real: (-b + sqrtDisc) / (2*a), imag: 0 });
                        poles.push({ real: (-b - sqrtDisc) / (2*a), imag: 0 });
                    } else {
                        const realPart = -b / (2*a);
                        const imagPart = Math.sqrt(-discriminant) / (2*a);
                        poles.push({ real: realPart, imag: imagPart });
                        poles.push({ real: realPart, imag: -imagPart });
                    }
                } else {
                    // 简化：假设一个实根和一对共轭复根
                    // 这是很粗略的近似，仅用于演示
                    const realRoot = -Math.cbrt(d/a);
                    poles.push({ real: realRoot, imag: 0 });
                    
                    // 假设其他两个根是共轭复根
                    const sum = -b/a - realRoot;
                    const product = c/a - b*realRoot/a;
                    
                    const realPart = sum / 2;
                    const discriminant = sum*sum - 4*product;
                    
                    if (discriminant < 0) {
                        const imagPart = Math.sqrt(-discriminant) / 2;
                        poles.push({ real: realPart, imag: imagPart });
                        poles.push({ real: realPart, imag: -imagPart });
                    } else {
                        const sqrtDisc = Math.sqrt(discriminant);
                        poles.push({ real: (sum + sqrtDisc) / 2, imag: 0 });
                        poles.push({ real: (sum - sqrtDisc) / 2, imag: 0 });
                    }
                }
            } else {
                // 使用原始系统的极点
                poles = calculatePoles();
            }
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // 找出极点的最大绝对值，用于自适应缩放
            let maxAbsReal = 0;
            let maxAbsImag = 0;
            
            poles.forEach(pole => {
                maxAbsReal = Math.max(maxAbsReal, Math.abs(pole.real));
                maxAbsImag = Math.max(maxAbsImag, Math.abs(pole.imag));
            });
            
            // 计算合适的缩放因子（留出20%的边距）
            const padding = 0.2;
            const scaleReal = width / 2 * (1 - padding) / (maxAbsReal || 1);
            const scaleImag = height / 2 * (1 - padding) / (maxAbsImag || 1);
            const scaleFactor = Math.min(scaleReal, scaleImag);
            
            // 添加刻度标签
            const addScaleMark = (value, isHorizontal) => {
                const mark = document.createElement('div');
                mark.className = 'axis-label';
                mark.textContent = value.toFixed(1);
                mark.style.fontSize = '10px';
                
                if (isHorizontal) {
                    const x = width/2 + value * scaleFactor;
                    mark.style.left = `${x}px`;
                    mark.style.top = `${height/2 + 15}px`;
                } else {
                    const y = height/2 - value * scaleFactor;
                    mark.style.left = `${width/2 + 15}px`;
                    mark.style.top = `${y}px`;
                }
                
                container.appendChild(mark);
            };
            
            // 添加实轴刻度
            if (maxAbsReal > 0) {
                const step = maxAbsReal / 2;
                addScaleMark(-step, true);
                addScaleMark(step, true);
            }
            
            // 添加虚轴刻度
            if (maxAbsImag > 0) {
                const step = maxAbsImag / 2;
                addScaleMark(step, false);
                addScaleMark(-step, false);
            }
            
            // 添加原点标签
            const origin = document.createElement('div');
            origin.className = 'axis-label';
            origin.textContent = '0';
            origin.style.left = `${width/2 + 15}px`;
            origin.style.top = `${height/2 + 15}px`;
            origin.style.fontSize = '10px';
            container.appendChild(origin);
            
            // 添加极点
            poles.forEach((pole, index) => {
                const x = width/2 + pole.real * scaleFactor;
                const y = height/2 - pole.imag * scaleFactor;
                
                // 确保极点在可视区域内
                if (x >= 0 && x <= width && y >= 0 && y <= height) {
                    const poleElement = document.createElement('div');
                    poleElement.className = 'pole';
                    poleElement.style.left = `${x}px`;
                    poleElement.style.top = `${y}px`;
                    container.appendChild(poleElement);
                    
                    // 添加极点标签
                    const poleLabel = document.createElement('div');
                    poleLabel.className = 'pole-label';
                    poleLabel.innerHTML = `s<sub>${index+1}</sub> = \\(${pole.real.toFixed(2)}${pole.imag >= 0 ? '+' : ''}${pole.imag.toFixed(2)}j\\)`;
                    poleLabel.style.left = `${x + 30}px`; // 大幅增加偏移量，避免与点重叠
                    poleLabel.style.top = `${y}px`;
                    container.appendChild(poleLabel);
                    
                    // 为新添加的极点标签渲染LaTeX
                    renderMathInElement(poleLabel);
                }
            });
            
            // 添加系统参数信息
            const wn = Math.sqrt(springK / mass);  // 自然频率
            const zeta = damping / (2 * Math.sqrt(mass * springK));  // 阻尼比
            
            const sysInfoContainer = document.createElement('div');
            sysInfoContainer.style.marginTop = '10px';
            sysInfoContainer.style.fontSize = '12px';
            sysInfoContainer.innerHTML = `
                <div class="latex-formula"><strong>自然频率</strong>: \\(\\omega_n = \\sqrt{\\frac{k}{m}} = ${wn.toFixed(2)} \\text{ rad/s}\\)</div>
                <div class="latex-formula"><strong>阻尼比</strong>: \\(\\zeta = \\frac{c}{2\\sqrt{km}} = ${zeta.toFixed(2)}\\) ${zeta < 1 ? '(欠阻尼)' : zeta === 1 ? '(临界阻尼)' : '(过阻尼)'}</div>
            `;
            
            const existingInfo = document.getElementById('s-plane-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            sysInfoContainer.id = 's-plane-info';
            document.getElementById('s-plane').appendChild(sysInfoContainer);
            
            // 重新渲染新添加的LaTeX公式
            renderMathInElement(sysInfoContainer);
            
            // 更新特征方程显示
            const characteristicEquation = document.getElementById('characteristic-equation');
            characteristicEquation.innerHTML = `特征方程：\\(${mass}s^2 + ${damping}s + ${springK} = 0\\)`;
            renderMathInElement(characteristicEquation);
        }
        
        // 更新时域响应图
        function updateTimeResponse() {
            const response = calculateStepResponse();
            
            // 更新图表配置，以便显示更多信息
            if (pidEnabled) {
                // 使用PID控制时，显示响应、控制信号和误差
                timeResponseChart.data.labels = response.timeData;
                
                // 确保数据集数量正确
                while (timeResponseChart.data.datasets.length < 3) {
                    const colors = ['#e74c3c', '#3498db', '#2ecc71'];
                    const labels = ['位移 x(t)', '控制信号 u(t)', '误差 e(t)'];
                    
                    timeResponseChart.data.datasets.push({
                        label: labels[timeResponseChart.data.datasets.length],
                        data: [],
                        borderColor: colors[timeResponseChart.data.datasets.length],
                        borderWidth: 2,
                        fill: false,
                        tension: 0.2,
                        pointRadius: 0,
                        hidden: timeResponseChart.data.datasets.length > 0 // 默认只显示位移
                    });
                }
                
                timeResponseChart.data.datasets[0].data = response.responseData;
                timeResponseChart.data.datasets[1].data = response.controlData;
                timeResponseChart.data.datasets[2].data = response.errorData;
                
                // 添加设定值参考线
                try {
                    timeResponseChart.options.plugins.annotation = {
                        annotations: {
                            setpointLine: {
                                type: 'line',
                                yMin: setpoint,
                                yMax: setpoint,
                                borderColor: 'rgba(46, 204, 113, 0.5)',
                                borderWidth: 2,
                                label: {
                                    content: `设定值: ${setpoint}`,
                                    enabled: true,
                                    position: 'end'
                                }
                            }
                        }
                    };
                } catch (e) {
                    console.error("设置注释时出错:", e);
                }
            } else {
                // 不使用PID控制时，只显示响应
                timeResponseChart.data.labels = response.timeData;
                timeResponseChart.data.datasets[0].data = response.responseData;
                
                // 隐藏额外的数据集
                if (timeResponseChart.data.datasets.length > 1) {
                    for (let i = 1; i < timeResponseChart.data.datasets.length; i++) {
                        timeResponseChart.data.datasets[i].hidden = true;
                    }
                }
                
                // 移除设定值参考线
                try {
                    timeResponseChart.options.plugins.annotation = {
                        annotations: {}
                    };
                } catch (e) {
                    console.error("清除注释时出错:", e);
                }
            }
            
            // 使用点状图更清晰显示数据点
            try {
                timeResponseChart.update();
            } catch (e) {
                console.error("更新图表时出错:", e);
            }
            
            // 更新PID控制信息
            if (pidEnabled) {
                const response = calculatePIDResponse();
                
                // 计算性能指标
                const maxOvershoot = Math.max(...response.responseData) - setpoint;
                const overshootPercent = maxOvershoot > 0 ? (maxOvershoot / setpoint) * 100 : 0;
                
                // 找到稳态误差
                const steadyStateError = Math.abs(response.responseData[response.responseData.length - 1] - setpoint);
                
                // 找到上升时间 (10% 到 90%)
                let riseTime = 0;
                const target10 = 0.1 * setpoint;
                const target90 = 0.9 * setpoint;
                let found10 = false;
                
                for (let i = 0; i < response.responseData.length; i++) {
                    if (!found10 && response.responseData[i] >= target10) {
                        found10 = true;
                    }
                    
                    if (found10 && response.responseData[i] >= target90) {
                        riseTime = response.timeData[i];
                        break;
                    }
                }
                
                // 找到稳定时间 (误差在±2%内)
                let settlingTime = response.timeData[response.timeData.length - 1];
                const errorBand = 0.02 * setpoint;
                
                for (let i = response.responseData.length - 1; i >= 0; i--) {
                    if (Math.abs(response.responseData[i] - setpoint) > errorBand) {
                        settlingTime = response.timeData[i + 1];
                        break;
                    }
                }
                
                // 更新PID信息区域
                pidInfo.innerHTML = `
                    <div><strong>系统性能指标:</strong></div>
                    <div>超调量: ${overshootPercent.toFixed(2)}%</div>
                    <div>上升时间: ${riseTime.toFixed(2)} 秒</div>
                    <div>稳定时间: ${settlingTime.toFixed(2)} 秒</div>
                    <div>稳态误差: ${steadyStateError.toFixed(4)}</div>
                `;
            } else {
                // 不使用PID控制时，清空PID信息区域
                pidInfo.innerHTML = "";
            }
        }
        
        // 更新Bode图
        function updateBodePlot() {
            try {
                console.log("更新Bode图, PID状态:", pidEnabled, "kp:", kp, "ki:", ki, "kd:", kd);
                let freqData, magData, phaseData;
                let bandwidth = 0; // 系统带宽
                
                if (pidEnabled) {
                    // 计算带PID控制器的闭环频率响应
                    const frequencyPoints = 100;
                    const minFreq = 0.1;
                    const maxFreq = 100;
                    const logStep = Math.pow(maxFreq / minFreq, 1 / (frequencyPoints - 1));
                    
                    freqData = [];
                    magData = [];
                    phaseData = [];
                    
                    // 将当前PID参数值存储在局部变量中，确保计算过程中使用的是一致的值
                    const currentKp = kp;
                    const currentKi = ki;
                    const currentKd = kd;
                    
                    for (let i = 0; i < frequencyPoints; i++) {
                        const w = minFreq * Math.pow(logStep, i);
                        freqData.push(w);
                        
                        try {
                            // 计算系统传递函数: G(s) = 1/(ms^2 + cs + k)
                            const den_real = springK - mass * w * w;
                            const den_imag = damping * w;
                            const G_mag = 1 / Math.sqrt(den_real * den_real + den_imag * den_imag);
                            const G_phase = -Math.atan2(den_imag, den_real);
                            
                            // 计算PID控制器: C(s) = Kp + Ki/s + Kd*s
                            const P_mag = currentKp;
                            const P_phase = 0;
                            
                            const I_mag = currentKi / w;
                            const I_phase = -Math.PI / 2;
                            
                            const D_mag = currentKd * w;
                            const D_phase = Math.PI / 2;
                            
                            // 计算PID控制器的实部和虚部
                            const P_real = P_mag * Math.cos(P_phase);
                            const P_imag = P_mag * Math.sin(P_phase);
                            
                            const I_real = I_mag * Math.cos(I_phase);
                            const I_imag = I_mag * Math.sin(I_phase);
                            
                            const D_real = D_mag * Math.cos(D_phase);
                            const D_imag = D_mag * Math.sin(D_phase);
                            
                            const C_real = P_real + I_real + D_real;
                            const C_imag = P_imag + I_imag + D_imag;
                            
                            const C_mag = Math.sqrt(C_real * C_real + C_imag * C_imag);
                            const C_phase = Math.atan2(C_imag, C_real);
                            
                            // 计算开环传递函数: L(s) = C(s)*G(s)
                            const L_mag = C_mag * G_mag;
                            const L_phase = C_phase + G_phase;
                            
                            const L_real = L_mag * Math.cos(L_phase);
                            const L_imag = L_mag * Math.sin(L_phase);
                            
                            // 计算闭环传递函数: T(s) = L(s)/(1 + L(s))
                            const den_T_real = 1 + L_real;
                            const den_T_imag = L_imag;
                            const den_T_mag = Math.sqrt(den_T_real * den_T_real + den_T_imag * den_T_imag);
                            
                            const T_mag = L_mag / den_T_mag;
                            const T_phase = L_phase - Math.atan2(den_T_imag, den_T_real);
                            
                            // 转换为dB和度
                            const magdB = 20 * Math.log10(T_mag);
                            const phaseDeg = T_phase * 180 / Math.PI;
                            
                            magData.push(magdB);
                            phaseData.push(phaseDeg);
                        } catch (err) {
                            console.error("计算频率响应出错:", err, "频率:", w);
                            // 出错时添加默认值
                            magData.push(0);
                            phaseData.push(0);
                        }
                    }
                    
                    // 查找带宽（-3dB频率）
                    for (let i = 0; i < magData.length; i++) {
                        if (magData[i] <= -3) {
                            if (i > 0) {
                                // 线性插值估计-3dB频率
                                const freq1 = freqData[i-1];
                                const freq2 = freqData[i];
                                const mag1 = magData[i-1];
                                const mag2 = magData[i];
                                bandwidth = freq1 + (freq2 - freq1) * ((-3) - mag1) / (mag2 - mag1);
                            } else {
                                bandwidth = freqData[i];
                            }
                            break;
                        }
                    }
                    
                    // 查找相位裕度（0dB增益交越频率处的相位与-180°的差值）
                    let phaseMargin = 0;
                    let gainCrossoverFreq = 0;
                    for (let i = 0; i < magData.length; i++) {
                        if (magData[i] <= 0) {
                            if (i > 0) {
                                // 线性插值估计0dB交越频率
                                const freq1 = freqData[i-1];
                                const freq2 = freqData[i];
                                const mag1 = magData[i-1];
                                const mag2 = magData[i];
                                gainCrossoverFreq = freq1 + (freq2 - freq1) * (0 - mag1) / (mag2 - mag1);
                                
                                // 线性插值估计相位
                                const phase1 = phaseData[i-1];
                                const phase2 = phaseData[i];
                                const phaseAtCrossover = phase1 + (phase2 - phase1) * (gainCrossoverFreq - freq1) / (freq2 - freq1);
                                phaseMargin = 180 + phaseAtCrossover;
                            }
                            break;
                        }
                    }
                    
                    // 在Bode图信息区域显示带宽和相位裕度
                    let bodeInfoContainer = document.getElementById('bode-info');
                    if (!bodeInfoContainer) {
                        bodeInfoContainer = document.createElement('div');
                        bodeInfoContainer.id = 'bode-info';
                        bodeInfoContainer.style.marginTop = '10px';
                        bodeInfoContainer.style.fontSize = '12px';
                        document.getElementById('frequency-domain').appendChild(bodeInfoContainer);
                    }
                    
                    bodeInfoContainer.innerHTML = `
                        <div><strong>闭环系统带宽:</strong> ${bandwidth.toFixed(2)} rad/s</div>
                        <div><strong>相位裕度:</strong> ${phaseMargin.toFixed(2)}°</div>
                        <div><strong>PID参数:</strong> Kp=${currentKp}, Ki=${currentKi}, Kd=${currentKd}</div>
                    `;
                } else {
                    // 使用原始系统的频率响应
                    const calculated = calculateBodeData();
                    freqData = calculated.freqData;
                    magData = calculated.magData;
                    phaseData = calculated.phaseData;
                    
                    // 计算原始系统带宽
                    // 获取系统在低频时的基础增益
                    const lowFreqGain = magData[0];
                    const thresholdGain = lowFreqGain - 3; // -3dB参考线相对于低频增益
                    
                    for (let i = 0; i < magData.length; i++) {
                        if (magData[i] <= thresholdGain) {
                            if (i > 0) {
                                // 线性插值估计-3dB频率
                                const freq1 = freqData[i-1];
                                const freq2 = freqData[i];
                                const mag1 = magData[i-1];
                                const mag2 = magData[i];
                                bandwidth = freq1 + (freq2 - freq1) * ((thresholdGain) - mag1) / (mag2 - mag1);
                            } else {
                                bandwidth = freqData[i];
                            }
                            break;
                        }
                    }
                    
                    // 添加系统信息
                    let bodeInfoContainer = document.getElementById('bode-info');
                    if (!bodeInfoContainer) {
                        bodeInfoContainer = document.createElement('div');
                        bodeInfoContainer.id = 'bode-info';
                        bodeInfoContainer.style.marginTop = '10px';
                        bodeInfoContainer.style.fontSize = '12px';
                        document.getElementById('frequency-domain').appendChild(bodeInfoContainer);
                    }
                    
                    const wn = Math.sqrt(springK / mass);  // 自然频率
                    const zeta = damping / (2 * Math.sqrt(mass * springK));  // 阻尼比
                    
                    bodeInfoContainer.innerHTML = `
                        <div><strong>系统带宽:</strong> ${bandwidth.toFixed(2)} rad/s</div>
                        <div><strong>自然频率:</strong> ${wn.toFixed(2)} rad/s</div>
                        <div><strong>阻尼比:</strong> ${zeta.toFixed(2)}</div>
                        <div><strong>低频增益:</strong> ${lowFreqGain.toFixed(2)} dB</div>
                    `;
                }
                
                // 创建0dB和-180°参考线数据
                const zeroDB = Array(freqData.length).fill(0);
                const neg180Phase = Array(freqData.length).fill(-180);
                
                // 更新图表数据
                bodeCombinedChart.data.labels = freqData;
                bodeCombinedChart.data.datasets[0].data = magData;
                bodeCombinedChart.data.datasets[1].data = phaseData;
                bodeCombinedChart.data.datasets[2].data = zeroDB;
                bodeCombinedChart.data.datasets[3].data = neg180Phase;
                
                // 配置-3dB带宽垂直线注释
                if (bandwidth > 0) {
                    // 对于未使用PID控制的系统，使用相对于低频增益的-3dB点
                    const thresholdDB = pidEnabled ? -3 : (magData[0] - 3);
                    
                    bodeCombinedChart.options.plugins.annotation = {
                        annotations: {
                            bandwidthLine: {
                                type: 'line',
                                xMin: bandwidth,
                                xMax: bandwidth,
                                borderColor: 'rgba(155, 89, 182, 0.7)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                label: {
                                    display: true,
                                    content: `-3dB 带宽: ${bandwidth.toFixed(2)} rad/s`,
                                    position: 'top',
                                    backgroundColor: 'rgba(155, 89, 182, 0.7)',
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            thresholdLine: {
                                type: 'line',
                                yMin: thresholdDB,
                                yMax: thresholdDB,
                                borderColor: 'rgba(155, 89, 182, 0.5)',
                                borderWidth: 1,
                                borderDash: [3, 3],
                                yScaleID: 'y-magnitude'
                            }
                        }
                    };
                    
                    // 移除之前的-3dB水平线数据集
                    if (bodeCombinedChart.data.datasets.length > 4) {
                        bodeCombinedChart.data.datasets = bodeCombinedChart.data.datasets.slice(0, 4);
                    }
                }
                
                // 更新标题以反映当前显示的是什么传递函数
                if (pidEnabled) {
                    bodeCombinedChart.options.plugins.title = {
                        display: true,
                        text: '闭环系统Bode图',
                        font: {
                            size: 14
                        }
                    };
                    
                    // 更新Y轴范围以适应闭环响应
                    bodeCombinedChart.options.scales['y-magnitude'].min = -40;
                    bodeCombinedChart.options.scales['y-magnitude'].max = 20;
                } else {
                    bodeCombinedChart.options.plugins.title = {
                        display: true,
                        text: '开环系统Bode图',
                        font: {
                            size: 14
                        }
                    };
                    
                    // 自适应Y轴范围，考虑低频增益
                    const minMag = Math.min(...magData) - 5;
                    const maxMag = Math.max(10, magData[0] + 5);
                    bodeCombinedChart.options.scales['y-magnitude'].min = minMag;
                    bodeCombinedChart.options.scales['y-magnitude'].max = maxMag;
                }
                
                // 强制更新图表
                bodeCombinedChart.update('none'); // 使用'none'动画模式更快地更新
                console.log("Bode图更新完成");
            } catch (e) {
                console.error("更新Bode图时出错:", e);
            }
        }
        
        // 更新物理系统动画
        let animationId;
        let startTime;
        
        function updateAnimation() {
            if (!stepInput) {
                cancelAnimationFrame(animationId);
                return;
            }
            
            const currentTime = performance.now();
            const elapsedTime = (currentTime - startTime) / 1000;  // 转换为秒
            
            // 计算实际时间间隔
            const dt = (currentTime - lastTime) / 1000; // 实际帧间隔，秒
            lastTime = currentTime;
            
            // 计算系统参数
            const wn = Math.sqrt(springK / mass);  // 自然频率
            const zeta = damping / (2 * Math.sqrt(mass * springK));  // 阻尼比
            
            // 计算位置
            let position;
            
            if (pidEnabled) {
                // 改进的PID控制计算
                const error = setpoint - previousPosition;
                
                // 积分项使用梯形法则累加
                integralSum += error * dt;
                
                // 微分项使用实际时间差
                const derivative = dt > 0.001 ? (error - lastError) / dt : 0;
                lastError = error;
                
                // 计算PID控制信号
                const controlSignal = kp * error + ki * integralSum + kd * derivative;
                
                // 系统动力学方程
                const acceleration = (controlSignal - damping * velocity - springK * previousPosition) / mass;
                velocity += acceleration * dt;
                position = previousPosition + velocity * dt;
                previousPosition = position;
            } else {
                // 原始弹簧-质量-阻尼系统的阶跃响应
                if (zeta < 1) {  // 欠阻尼
                    const wd = wn * Math.sqrt(1 - zeta * zeta);  // 阻尼振荡频率
                    position = 1 - (Math.exp(-zeta * wn * elapsedTime) / Math.sqrt(1 - zeta * zeta)) * 
                        Math.sin(wd * elapsedTime + Math.atan(Math.sqrt(1 - zeta * zeta) / zeta));
                } else if (zeta === 1) {  // 临界阻尼
                    position = 1 - Math.exp(-wn * elapsedTime) * (1 + wn * elapsedTime);
                } else {  // 过阻尼
                    const p1 = -wn * (zeta + Math.sqrt(zeta * zeta - 1));
                    const p2 = -wn * (zeta - Math.sqrt(zeta * zeta - 1));
                    position = 1 + (p2 * Math.exp(p1 * elapsedTime) - p1 * Math.exp(p2 * elapsedTime)) / (p2 - p1);
                }
            }
            
            // 防止NaN或无限值导致动画异常
            if (isNaN(position) || !isFinite(position)) {
                console.error("动画计算错误，位置值无效");
                position = previousPosition || 0;
            }
            
            // 为动画设置合适的缩放
            const scaleFactor = 50;  // 调整以适应动画区域
            const displacement = position * scaleFactor;
            
            // 限制位移范围，防止元素移出可视区域
            const limitedDisplacement = Math.max(-50, Math.min(150, displacement));
            
            // 更新质量位置
            massElement.style.transform = `translateX(${limitedDisplacement}px)`;
            
            // 更新弹簧长度
            springElement.style.width = `${80 + limitedDisplacement}px`;
            
            // 更新阻尼器位置
            damperElement.style.transform = `translateX(${limitedDisplacement}px)`;
            
            // 速度视觉反馈（通过颜色）
            const velocityColor = Math.abs(velocity) * 5;
            const r = Math.min(255, 231 + velocityColor);
            const g = Math.max(0, 76 - velocityColor);
            const b = Math.max(0, 60 - velocityColor);
            massElement.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            
            animationId = requestAnimationFrame(updateAnimation);
        }
        
        // 开始阶跃响应动画
        function startStepResponse() {
            stepInput = true;
            forceArrow.style.display = 'block';
            startTime = performance.now();
            previousPosition = 0;
            velocity = 0; // 重置速度
            lastError = 0; // 重置上一次误差
            integralSum = 0; // 重置积分累加
            lastTime = startTime; // 初始化时间
            
            // 重置元素位置
            massElement.style.transform = 'translateX(0)';
            springElement.style.width = '80px';
            damperElement.style.transform = 'translateX(0)';
            
            cancelAnimationFrame(animationId);
            animationId = requestAnimationFrame(updateAnimation);
        }
        
        // 更新所有可视化
        function updateVisualizations() {
            console.log("开始更新所有可视化 - PID状态:", pidEnabled, "系统参数:", {mass, damping, springK}, "PID参数:", {kp, ki, kd, setpoint});
            
            // 更新方程
            updateEquations();
            
            // 更新时域响应
            updateTimeResponse();
            
            // 更新Bode图
            updateBodePlot();
            
            // 更新极点图
            updatePolePlot();
            
            // 更新传递函数显示
            updateClosedLoopDisplay();
            
            console.log("所有可视化更新完成");
        }
        
        // 添加专门用于更新传递函数的函数
        function updateTransferFunctions() {
            console.log("更新传递函数 - PID状态:", pidEnabled, "PID参数:", {kp, ki, kd});
            
            try {
                // 采用更直接的方法更新传递函数显示
                const pidFormula = document.getElementById('pid-transfer-function');
                const closedLoopFormula = document.getElementById('closed-loop-simplified');
                
                // 完全清除内容
                while (pidFormula.firstChild) {
                    pidFormula.removeChild(pidFormula.firstChild);
                }
                
                while (closedLoopFormula.firstChild) {
                    closedLoopFormula.removeChild(closedLoopFormula.firstChild);
                }
                
                // 创建新的文本节点
                const pidText = document.createTextNode(`\\[C(s) = ${kp} + \\frac{${ki}}{s} + ${kd}s\\]`);
                pidFormula.appendChild(pidText);
                
                let closedLoopText;
                if (pidEnabled) {
                    closedLoopText = document.createTextNode(`\\[T(s) = \\frac{${kd}s^2 + ${kp}s + ${ki}}{${mass}s^3 + (${damping}+${kd})s^2 + (${springK}+${kp})s + ${ki}}\\]`);
                } else {
                    closedLoopText = document.createTextNode(`\\[T(s) = \\frac{1}{${mass}s^2 + ${damping}s + ${springK}}\\]`);
                }
                closedLoopFormula.appendChild(closedLoopText);
                
                console.log("准备渲染LaTeX...");
                
                // 尝试使用KaTeX直接渲染
                try {
                    renderMathInElement(document.body, {
                        delimiters: [
                            {left: "$$", right: "$$", display: true},
                            {left: "$", right: "$", display: false},
                            {left: "\\(", right: "\\)", display: false},
                            {left: "\\[", right: "\\]", display: true}
                        ],
                        throwOnError: false
                    });
                    console.log("LaTeX渲染完成");
                } catch (renderErr) {
                    console.error("LaTeX渲染失败:", renderErr);
                }
                
                console.log("传递函数更新完成");
            } catch (err) {
                console.error("更新传递函数时出错:", err);
            }
        }
        
        // 滑块事件监听器
        massSlider.addEventListener('input', function() {
            mass = parseFloat(this.value);
            massValue.textContent = `${mass} kg`;
            updateVisualizations();
        });
        
        dampingSlider.addEventListener('input', function() {
            damping = parseFloat(this.value);
            dampingValue.textContent = `${damping} N·s/m`;
            updateVisualizations();
        });
        
        springSlider.addEventListener('input', function() {
            springK = parseFloat(this.value);
            springValue.textContent = `${springK} N/m`;
            updateVisualizations();
        });
        
        // 重置按钮
        resetButton.addEventListener('click', function() {
            mass = 1;
            damping = 2;
            springK = 10;
            
            massSlider.value = mass;
            dampingSlider.value = damping;
            springSlider.value = springK;
            
            massValue.textContent = `${mass} kg`;
            dampingValue.textContent = `${damping} N·s/m`;
            springValue.textContent = `${springK} N/m`;
            
            stepInput = false;
            forceArrow.style.display = 'none';
            
            // 重置元素位置
            massElement.style.transform = 'translateX(0)';
            springElement.style.width = '80px';
            damperElement.style.transform = 'translateX(0)';
            
            updateVisualizations();
        });
        
        // 阶跃输入按钮
        stepInputButton.addEventListener('click', startStepResponse);
        
        // 选项卡切换
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });
        
        // PID控制器事件监听器
        pidEnableCheckbox.addEventListener('change', function() {
            pidEnabled = this.checked;
            console.log("PID状态变更为:", pidEnabled);
            
            // 重置PID相关变量
            previousPosition = 0;
            velocity = 0;
            lastError = 0;
            integralSum = 0;
            
            // 重置动画位置
            massElement.style.transform = 'translateX(0)';
            springElement.style.width = '80px';
            damperElement.style.transform = 'translateX(0)';
            
            // 立即更新传递函数显示
            updateClosedLoopDisplay();
            
            // 然后更新其他可视化
            updateEquations();
            updateTimeResponse();
            updateBodePlot();
            updatePolePlot();
            
            console.log("PID状态切换更新完成");
        });
        
        kpSlider.addEventListener('input', function() {
            kp = parseFloat(this.value);
            kpValue.textContent = kp;
            console.log("Kp值更新为:", kp);
            if (pidEnabled) {
                // 使用新方法更新传递函数
                updateClosedLoopDisplay();
                // 更新Bode图和极点图
                updateBodePlot();
                updatePolePlot();
            } else {
                updateVisualizations();
            }
        });
        
        kiSlider.addEventListener('input', function() {
            ki = parseFloat(this.value);
            kiValue.textContent = ki;
            console.log("Ki值更新为:", ki);
            if (pidEnabled) {
                // 使用新方法更新传递函数
                updateClosedLoopDisplay();
                // 更新Bode图和极点图
                updateBodePlot();
                updatePolePlot();
            } else {
                updateVisualizations();
            }
        });
        
        kdSlider.addEventListener('input', function() {
            kd = parseFloat(this.value);
            kdValue.textContent = kd;
            console.log("Kd值更新为:", kd);
            if (pidEnabled) {
                // 使用新方法更新传递函数
                updateClosedLoopDisplay();
                // 更新Bode图和极点图
                updateBodePlot();
                updatePolePlot();
            } else {
                updateVisualizations();
            }
        });
        
        setpointSlider.addEventListener('input', function() {
            setpoint = parseFloat(this.value);
            setpointValue.textContent = setpoint;
            console.log("设定值更新为:", setpoint);
            // 设定值主要影响时域响应
            updateTimeResponse();
        });
        
        // 初始化
        window.addEventListener('load', function() {
            try {
                console.log("初始化图表...");
                initCharts();
                console.log("更新可视化...");
                updateVisualizations();
                console.log("渲染LaTeX公式...");
                renderLatexFormulas();
                
                console.log("初始化完成");
            } catch (e) {
                console.error("初始化过程中出错:", e);
            }
        });
        
        // 更新闭环传递函数显示
        function updateClosedLoopDisplay() {
            console.log("专门更新闭环传递函数显示 - PID状态:", pidEnabled);
            
            const mainDisplay = document.getElementById('closed-loop-simplified');
            const pidDisplay = document.getElementById('pid-closed-loop');
            const nonPidDisplay = document.getElementById('non-pid-closed-loop');
            
            // 更新辅助显示区域的内容
            if (pidEnabled) {
                // 更新PID状态下的公式
                pidDisplay.innerHTML = `\\[T(s) = \\frac{${kd}s^2 + ${kp}s + ${ki}}{${mass}s^3 + (${damping}+${kd})s^2 + (${springK}+${kp})s + ${ki}}\\]`;
                
                // 显示PID版本，隐藏非PID版本
                pidDisplay.style.display = 'block';
                nonPidDisplay.style.display = 'none';
                mainDisplay.style.display = 'none';
            } else {
                // 更新非PID状态下的公式
                nonPidDisplay.innerHTML = `\\[T(s) = \\frac{1}{${mass}s^2 + ${damping}s + ${springK}}\\]`;
                
                // 显示非PID版本，隐藏PID版本
                pidDisplay.style.display = 'none';
                nonPidDisplay.style.display = 'block';
                mainDisplay.style.display = 'none';
            }
            
            // 渲染LaTeX公式
            renderMathInElement(pidDisplay);
            renderMathInElement(nonPidDisplay);
            
            console.log("闭环传递函数显示更新完成");
        }
    </script>
</body>
</html>
