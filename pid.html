<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>弹簧-质量-阻尼系统演示</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.8.0/lib/browser/math.min.js"></script>
    <!-- 添加KaTeX支持 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <style>
        body {
            font-family: "Microsoft YaHei", Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        .panel {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fff;
        }
        .system-animation {
            width: 100%;
            height: 200px;
            border: 1px solid #ccc;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
            background-color: #f9f9f9;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            width: 150px;
        }
        .value-display {
            width: 40px;
            text-align: center;
        }
        button {
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #2980b9;
        }
        .equation-box {
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-family: "Cambria Math", Georgia, serif;
            margin: 10px 0;
            overflow-x: auto;
        }
        .plot-container {
            height: 250px;
            margin: 15px 0;
        }
        .spring {
            position: absolute;
            height: 20px;
            background-color: #7f8c8d;
            bottom: 100px;
            left: 50px;
            width: 80px;
        }
        .mass {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #e74c3c;
            bottom: 90px;
            left: 130px;
            border-radius: 5px;
        }
        .damper {
            position: absolute;
            height: 60px;
            width: 10px;
            background-color: #3498db;
            bottom: 70px;
            left: 200px;
        }
        .ground {
            position: absolute;
            height: 10px;
            background-color: #2c3e50;
            bottom: 70px;
            left: 0;
            width: 100%;
        }
        .force-arrow {
            position: absolute;
            width: 40px;
            height: 10px;
            background-color: #f39c12;
            bottom: 105px;
            left: 180px;
        }
        .tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        .tab.active {
            border-color: #ddd;
            background-color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .pole-zero-plot {
            width: 100%;
            height: 250px;
            position: relative;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            margin-top: 10px;
        }
        .pole {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #e74c3c;
            transform: translate(-50%, -50%);
        }
        .zero {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid #3498db;
            background-color: transparent;
            transform: translate(-50%, -50%);
        }
        .s-plane-axes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .x-axis, .y-axis {
            position: absolute;
            background-color: #333;
        }
        .x-axis {
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
        }
        .y-axis {
            width: 1px;
            height: 100%;
            top: 0;
            left: 50%;
        }
        .pole-label {
            position: absolute;
            font-size: 12px;
            color: #e74c3c;
            transform: translate(0, -10%);
            white-space: nowrap;
        }
        .axis-label {
            position: absolute;
            font-size: 12px;
            color: #333;
        }
        /* 添加LaTeX公式样式 */
        .latex-formula {
            text-align: center;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>弹簧-质量-阻尼系统动态演示</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="mass">质量 (m)</label>
                <div class="slider-container">
                    <input type="range" id="mass" min="0.1" max="5" step="0.1" value="1">
                    <span id="mass-value" class="value-display">1 kg</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="damping">阻尼系数 (c)</label>
                <div class="slider-container">
                    <input type="range" id="damping" min="0" max="10" step="0.1" value="2">
                    <span id="damping-value" class="value-display">2 N·s/m</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="spring">弹簧刚度 (k)</label>
                <div class="slider-container">
                    <input type="range" id="spring" min="1" max="30" step="0.1" value="10">
                    <span id="spring-value" class="value-display">10 N/m</span>
                </div>
            </div>
            
            <button id="reset-button">重置参数</button>
            <button id="step-input">施加阶跃输入</button>
        </div>
        
        <div class="flex-container">
            <div class="panel">
                <h2>物理系统</h2>
                <div class="system-animation" id="animation-container">
                    <div class="ground"></div>
                    <div class="spring" id="spring-element"></div>
                    <div class="mass" id="mass-element"></div>
                    <div class="damper" id="damper-element"></div>
                    <div class="force-arrow" id="force-arrow" style="display: none;"></div>
                </div>
                
                <h3>微分方程（时域表示）</h3>
                <div class="equation-box latex-formula" id="differential-equation">
                    m\ddot{x}(t) + c\dot{x}(t) + kx(t) = F(t)
                </div>
                
                <h3>传递函数（频域表示）</h3>
                <div class="equation-box latex-formula" id="transfer-function">
                    G(s) = \frac{1}{ms^2 + cs + k}
                </div>
            </div>
            
            <div class="panel">
                <div class="tabs">
                    <div class="tab active" data-tab="time-domain">时域分析</div>
                    <div class="tab" data-tab="frequency-domain">频域分析</div>
                    <div class="tab" data-tab="s-plane">s平面分析</div>
                </div>
                
                <div class="tab-content active" id="time-domain">
                    <h3>阶跃响应</h3>
                    <div class="plot-container">
                        <canvas id="time-response-chart"></canvas>
                    </div>
                    <p>
                        时域分析直接展示系统对输入的响应随时间的变化。
                        从阶跃响应中可以观察到：
                    </p>
                    <ul>
                        <li>上升时间：系统响应初始增长速度</li>
                        <li>峰值时间：达到第一个峰值的时间</li>
                        <li>超调量：峰值超过稳态值的百分比</li>
                        <li>稳定时间：响应进入稳态范围所需的时间</li>
                    </ul>
                </div>
                
                <div class="tab-content" id="frequency-domain">
                    <h3>Bode图</h3>
                    <div class="plot-container" style="height: 400px;">
                        <canvas id="bode-combined-chart"></canvas>
                    </div>
                    <p>
                        频域分析展示了系统在不同频率下的响应特性：
                    </p>
                    <ul>
                        <li>幅频特性：表示系统在各频率下的增益</li>
                        <li>相频特性：表示系统在各频率下的相位滞后</li>
                        <li>共振峰：表示系统的共振频率，与阻尼比相关</li>
                        <li>截止频率：系统幅值下降到-3dB的频率，表示系统带宽</li>
                        <li>相位富裕度：增益为0dB时的相位与-180°之间的差值</li>
                    </ul>
                </div>
                
                <div class="tab-content" id="s-plane">
                    <h3>极点零点分析</h3>
                    <div class="pole-zero-plot" id="pole-zero-container">
                        <div class="s-plane-axes">
                            <div class="x-axis"></div>
                            <div class="y-axis"></div>
                        </div>
                    </div>
                    <div class="equation-box latex-formula" id="characteristic-equation">
                        特征方程：ms^2 + cs + k = 0
                    </div>
                    <p>
                        s平面分析揭示了系统的稳定性和动态特性：
                    </p>
                    <ul>
                        <li>极点位于左半平面 → 系统稳定</li>
                        <li>极点位于虚轴 → 等幅振荡</li>
                        <li>极点位于右半平面 → 系统不稳定</li>
                        <li>极点到原点的距离 → 系统响应速度</li>
                        <li>极点与实轴的夹角 → 系统振荡频率</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>时域与频域的转换关系</h2>
            <p>
                拉普拉斯变换将时域中的微分方程转换为频域中的代数方程，极大地简化了分析过程。
                对于弹簧-质量-阻尼系统，其转换关系为：
            </p>
            <div class="equation-box">
                <div class="latex-formula">
                    \[m\ddot{x}(t) + c\dot{x}(t) + kx(t) = F(t)\]
                </div>
                <div style="text-align: center;">⬇️ 拉普拉斯变换 ⬇️</div>
                <div class="latex-formula">
                    \[ms^2X(s) + csX(s) + kX(s) = F(s)\]
                </div>
                <div style="text-align: center;">⬇️ 整理得到传递函数 ⬇️</div>
                <div class="latex-formula">
                    \[G(s) = \frac{X(s)}{F(s)} = \frac{1}{ms^2 + cs + k}\]
                </div>
            </div>
            <p>
                系统特性参数与传递函数的关系：
            </p>
            <ul>
                <li><strong>自然频率 ωn</strong> = \(\sqrt{\frac{k}{m}}\)：表示无阻尼时系统的振荡频率</li>
                <li><strong>阻尼比 ζ</strong> = \(\frac{c}{2\sqrt{km}}\)：描述系统阻尼程度</li>
                <li><strong>阻尼振荡频率 ωd</strong> = \(\omega_n\sqrt{1-\zeta^2}\)：实际振荡频率</li>
            </ul>
            <p>
                当调整系统参数时，可以观察到：
            </p>
            <ul>
                <li>增加质量(m)：降低自然频率，系统响应变慢</li>
                <li>增加阻尼(c)：减小振荡，极点向实轴移动</li>
                <li>增加刚度(k)：提高自然频率，Bode图右移</li>
            </ul>
        </div>
    </div>

    <script>
        // 系统参数
        let mass = 1;           // 质量 (kg)
        let damping = 2;        // 阻尼系数 (N·s/m)
        let springK = 10;       // 弹簧刚度 (N/m)
        let stepInput = false;  // 阶跃输入状态
        
        // 获取UI元素
        const massSlider = document.getElementById('mass');
        const dampingSlider = document.getElementById('damping');
        const springSlider = document.getElementById('spring');
        const massValue = document.getElementById('mass-value');
        const dampingValue = document.getElementById('damping-value');
        const springValue = document.getElementById('spring-value');
        const resetButton = document.getElementById('reset-button');
        const stepInputButton = document.getElementById('step-input');
        const differentialEquation = document.getElementById('differential-equation');
        const transferFunction = document.getElementById('transfer-function');
        const characteristicEquation = document.getElementById('characteristic-equation');
        const massElement = document.getElementById('mass-element');
        const springElement = document.getElementById('spring-element');
        const damperElement = document.getElementById('damper-element');
        const forceArrow = document.getElementById('force-arrow');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // 图表上下文
        let timeResponseChart;
        let bodeCombinedChart;
        
        // 初始化图表
        function initCharts() {
            // 时域响应图表
            const timeCtx = document.getElementById('time-response-chart').getContext('2d');
            timeResponseChart = new Chart(timeCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '位移 x(t)',
                        data: [],
                        borderColor: '#e74c3c',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.2,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '时间 (秒)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return Number(value).toFixed(1);
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '位移 (米)'
                            }
                        }
                    }
                }
            });
            
            // 合并的Bode图
            const bodeCombinedCtx = document.getElementById('bode-combined-chart').getContext('2d');
            bodeCombinedChart = new Chart(bodeCombinedCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: '幅值 (dB)',
                            data: [],
                            borderColor: '#3498db',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y-magnitude'
                        },
                        {
                            label: '相位 (度)',
                            data: [],
                            borderColor: '#2ecc71',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y-phase'
                        },
                        {
                            label: '0 dB参考线',
                            data: [],
                            borderColor: 'rgba(231, 76, 60, 0.5)',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y-magnitude'
                        },
                        {
                            label: '-180°参考线',
                            data: [],
                            borderColor: 'rgba(231, 76, 60, 0.5)',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y-phase'
                        },
                        {
                            label: '-3 dB参考线',
                            data: [],
                            borderColor: 'rgba(155, 89, 182, 0.5)',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y-magnitude'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    stacked: false,
                    scales: {
                        x: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: '频率 (rad/s)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return Number(value).toFixed(1);
                                }
                            }
                        },
                        'y-magnitude': {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: '幅值 (dB)'
                            },
                            grid: {
                                drawOnChartArea: true,
                            },
                        },
                        'y-phase': {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: '相位 (度)'
                            },
                            min: -180,
                            max: 0,
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                filter: function(item, chart) {
                                    // 隐藏参考线的图例
                                    return !item.text.includes('参考线');
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // 初始化KaTeX渲染
        function renderLatexFormulas() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ],
                throwOnError: false
            });
        }
        
        // 更新数学表达式
        function updateEquations() {
            differentialEquation.innerHTML = `\\[${mass}\\ddot{x}(t) + ${damping}\\dot{x}(t) + ${springK}x(t) = F(t)\\]`;
            transferFunction.innerHTML = `\\[G(s) = \\frac{1}{${mass}s^2 + ${damping}s + ${springK}}\\]`;
            characteristicEquation.innerHTML = `特征方程：\\[${mass}s^2 + ${damping}s + ${springK} = 0\\]`;
            
            // 重新渲染LaTeX
            renderMathInElement(differentialEquation);
            renderMathInElement(transferFunction);
            renderMathInElement(characteristicEquation);
        }
        
        // 计算阶跃响应
        function calculateStepResponse() {
            const timePoints = 100; // 减少数据点数量
            const maxTime = 10;
            const dt = maxTime / timePoints;
            
            // 计算系统参数
            const wn = Math.sqrt(springK / mass);  // 自然频率
            const zeta = damping / (2 * Math.sqrt(mass * springK));  // 阻尼比
            
            const timeData = [];
            const responseData = [];
            
            for (let i = 0; i < timePoints; i++) {
                const t = i * dt;
                timeData.push(Number(t.toFixed(2))); // 保留两位小数，避免浮点精度问题
                
                let x;
                if (zeta < 1) {  // 欠阻尼
                    const wd = wn * Math.sqrt(1 - zeta * zeta);  // 阻尼振荡频率
                    x = 1 - (Math.exp(-zeta * wn * t) / Math.sqrt(1 - zeta * zeta)) * 
                        Math.sin(wd * t + Math.atan(Math.sqrt(1 - zeta * zeta) / zeta));
                } else if (zeta === 1) {  // 临界阻尼
                    x = 1 - Math.exp(-wn * t) * (1 + wn * t);
                } else {  // 过阻尼
                    const p1 = -wn * (zeta + Math.sqrt(zeta * zeta - 1));
                    const p2 = -wn * (zeta - Math.sqrt(zeta * zeta - 1));
                    x = 1 + (p2 * Math.exp(p1 * t) - p1 * Math.exp(p2 * t)) / (p2 - p1);
                }
                
                responseData.push(x);
            }
            
            return { timeData, responseData };
        }
        
        // 计算Bode图数据
        function calculateBodeData() {
            const frequencyPoints = 100;
            const minFreq = 0.1;
            const maxFreq = 100;
            const logStep = Math.pow(maxFreq / minFreq, 1 / (frequencyPoints - 1));
            
            const freqData = [];
            const magData = [];
            const phaseData = [];
            
            for (let i = 0; i < frequencyPoints; i++) {
                const w = minFreq * Math.pow(logStep, i);
                freqData.push(w);
                
                // 计算传递函数在s = jw处的值
                const numerator = 1;
                const denominator = math.complex(springK - mass * w * w, damping * w);
                const G = math.divide(numerator, denominator);
                
                // 转换为dB和相位
                const magdB = 20 * Math.log10(math.abs(G));
                const phase = math.arg(G) * 180 / Math.PI;
                
                magData.push(magdB);
                phaseData.push(phase);
            }
            
            return { freqData, magData, phaseData };
        }
        
        // 计算系统极点
        function calculatePoles() {
            // 特征方程：ms^2 + cs + k = 0
            const wn = Math.sqrt(springK / mass);  // 自然频率
            const zeta = damping / (2 * Math.sqrt(mass * springK));  // 阻尼比
            
            // 极点位置
            if (zeta < 1) {  // 欠阻尼：复数共轭极点
                const realPart = -zeta * wn;
                const imagPart = wn * Math.sqrt(1 - zeta * zeta);
                return [
                    { real: realPart, imag: imagPart },
                    { real: realPart, imag: -imagPart }
                ];
            } else if (zeta === 1) {  // 临界阻尼：重极点
                return [
                    { real: -wn, imag: 0 },
                    { real: -wn, imag: 0 }
                ];
            } else {  // 过阻尼：两个实极点
                const sqrtTerm = Math.sqrt(zeta * zeta - 1);
                return [
                    { real: -wn * (zeta + sqrtTerm), imag: 0 },
                    { real: -wn * (zeta - sqrtTerm), imag: 0 }
                ];
            }
        }
        
        // 更新s平面极点图
        function updatePolePlot() {
            const container = document.getElementById('pole-zero-container');
            container.innerHTML = ''; // 清空容器
            
            // 添加坐标轴
            const axesContainer = document.createElement('div');
            axesContainer.className = 's-plane-axes';
            
            const xAxis = document.createElement('div');
            xAxis.className = 'x-axis';
            axesContainer.appendChild(xAxis);
            
            const yAxis = document.createElement('div');
            yAxis.className = 'y-axis';
            axesContainer.appendChild(yAxis);
            
            container.appendChild(axesContainer);
            
            // 添加轴标签
            const xLabel = document.createElement('div');
            xLabel.className = 'axis-label';
            xLabel.textContent = '实轴';
            xLabel.style.right = '10px';
            xLabel.style.top = '50%';
            xLabel.style.transform = 'translateY(-50%)';
            container.appendChild(xLabel);
            
            const yLabel = document.createElement('div');
            yLabel.className = 'axis-label';
            yLabel.textContent = '虚轴';
            yLabel.style.left = '50%';
            yLabel.style.top = '10px';
            yLabel.style.transform = 'translateX(-50%)';
            container.appendChild(yLabel);
            
            const poles = calculatePoles();
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // 找出极点的最大绝对值，用于自适应缩放
            let maxAbsReal = 0;
            let maxAbsImag = 0;
            
            poles.forEach(pole => {
                maxAbsReal = Math.max(maxAbsReal, Math.abs(pole.real));
                maxAbsImag = Math.max(maxAbsImag, Math.abs(pole.imag));
            });
            
            // 计算合适的缩放因子（留出20%的边距）
            const padding = 0.2;
            const scaleReal = width / 2 * (1 - padding) / (maxAbsReal || 1);
            const scaleImag = height / 2 * (1 - padding) / (maxAbsImag || 1);
            const scaleFactor = Math.min(scaleReal, scaleImag);
            
            // 添加刻度标签
            const addScaleMark = (value, isHorizontal) => {
                const mark = document.createElement('div');
                mark.className = 'axis-label';
                mark.textContent = value.toFixed(1);
                mark.style.fontSize = '10px';
                
                if (isHorizontal) {
                    const x = width/2 + value * scaleFactor;
                    mark.style.left = `${x}px`;
                    mark.style.top = `${height/2 + 15}px`;
                } else {
                    const y = height/2 - value * scaleFactor;
                    mark.style.left = `${width/2 + 15}px`;
                    mark.style.top = `${y}px`;
                }
                
                container.appendChild(mark);
            };
            
            // 添加实轴刻度
            if (maxAbsReal > 0) {
                const step = maxAbsReal / 2;
                addScaleMark(-step, true);
                addScaleMark(step, true);
            }
            
            // 添加虚轴刻度
            if (maxAbsImag > 0) {
                const step = maxAbsImag / 2;
                addScaleMark(step, false);
                addScaleMark(-step, false);
            }
            
            // 添加原点标签
            const origin = document.createElement('div');
            origin.className = 'axis-label';
            origin.textContent = '0';
            origin.style.left = `${width/2 + 15}px`;
            origin.style.top = `${height/2 + 15}px`;
            origin.style.fontSize = '10px';
            container.appendChild(origin);
            
            // 添加极点
            poles.forEach((pole, index) => {
                const x = width/2 + pole.real * scaleFactor;
                const y = height/2 - pole.imag * scaleFactor;
                
                // 确保极点在可视区域内
                if (x >= 0 && x <= width && y >= 0 && y <= height) {
                    const poleElement = document.createElement('div');
                    poleElement.className = 'pole';
                    poleElement.style.left = `${x}px`;
                    poleElement.style.top = `${y}px`;
                    container.appendChild(poleElement);
                    
                    // 添加极点标签
                    const poleLabel = document.createElement('div');
                    poleLabel.className = 'pole-label';
                    poleLabel.innerHTML = `s<sub>${index+1}</sub> = \\(${pole.real.toFixed(2)}${pole.imag >= 0 ? '+' : ''}${pole.imag.toFixed(2)}j\\)`;
                    poleLabel.style.left = `${x + 30}px`; // 大幅增加偏移量，避免与点重叠
                    poleLabel.style.top = `${y}px`;
                    container.appendChild(poleLabel);
                    
                    // 为新添加的极点标签渲染LaTeX
                    renderMathInElement(poleLabel);
                }
            });
            
            // 添加系统参数信息
            const wn = Math.sqrt(springK / mass);  // 自然频率
            const zeta = damping / (2 * Math.sqrt(mass * springK));  // 阻尼比
            
            const sysInfoContainer = document.createElement('div');
            sysInfoContainer.style.marginTop = '10px';
            sysInfoContainer.style.fontSize = '12px';
            sysInfoContainer.innerHTML = `
                <div class="latex-formula"><strong>自然频率</strong>: \\(\\omega_n = \\sqrt{\\frac{k}{m}} = ${wn.toFixed(2)} \\text{ rad/s}\\)</div>
                <div class="latex-formula"><strong>阻尼比</strong>: \\(\\zeta = \\frac{c}{2\\sqrt{km}} = ${zeta.toFixed(2)}\\) ${zeta < 1 ? '(欠阻尼)' : zeta === 1 ? '(临界阻尼)' : '(过阻尼)'}</div>
            `;
            
            const existingInfo = document.getElementById('s-plane-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            sysInfoContainer.id = 's-plane-info';
            document.getElementById('s-plane').appendChild(sysInfoContainer);
            
            // 重新渲染新添加的LaTeX公式
            renderMathInElement(sysInfoContainer);
            
            // 更新特征方程显示
            const characteristicEquation = document.getElementById('characteristic-equation');
            characteristicEquation.innerHTML = `特征方程：\\(${mass}s^2 + ${damping}s + ${springK} = 0\\)`;
            renderMathInElement(characteristicEquation);
        }
        
        // 更新时域响应图
        function updateTimeResponse() {
            const { timeData, responseData } = calculateStepResponse();
            
            // 使用点状图更清晰显示数据点
            timeResponseChart.data.labels = timeData;
            timeResponseChart.data.datasets[0].data = responseData;
            timeResponseChart.data.datasets[0].pointRadius = 0; // 不显示数据点
            timeResponseChart.data.datasets[0].tension = 0.2; // 平滑曲线
            timeResponseChart.update();
        }
        
        // 更新Bode图
        function updateBodePlot() {
            const { freqData, magData, phaseData } = calculateBodeData();
            
            // 找到DC增益（低频增益）
            let dcGain = magData[0]; // 假设第一个点接近DC
            for (let i = 0; i < Math.min(10, magData.length); i++) {
                if (freqData[i] < 0.1) {
                    dcGain = Math.max(dcGain, magData[i]);
                }
            }
            
            // 创建参考线数据
            const zeroDB = Array(freqData.length).fill(0);
            const neg180Phase = Array(freqData.length).fill(-180);
            const neg3dBLine = Array(freqData.length).fill(dcGain - 3); // 相对于DC增益的-3dB线
            
            // 更新图表数据
            bodeCombinedChart.data.labels = freqData;
            bodeCombinedChart.data.datasets[0].data = magData;
            bodeCombinedChart.data.datasets[1].data = phaseData;
            bodeCombinedChart.data.datasets[2].data = zeroDB;
            bodeCombinedChart.data.datasets[3].data = neg180Phase;
            bodeCombinedChart.data.datasets[4].data = neg3dBLine;
            bodeCombinedChart.update();
            
            // 计算并显示相位富裕度
            let phaseMarginDeg = null;
            let crossoverFreq = null;
            
            // 找到幅值穿越0dB的点 (增益交叉频率)
            for (let i = 0; i < magData.length - 1; i++) {
                if ((magData[i] >= 0 && magData[i+1] <= 0) || (magData[i] <= 0 && magData[i+1] >= 0)) {
                    // 使用线性插值找到准确的交叉点
                    const t = Math.abs(magData[i]) / Math.abs(magData[i+1] - magData[i]);
                    crossoverFreq = freqData[i] * (1-t) + freqData[i+1] * t;
                    
                    // 通过插值计算相应的相位
                    const phase1 = phaseData[i];
                    const phase2 = phaseData[i+1];
                    const phaseAtCrossover = phase1 * (1-t) + phase2 * t;
                    
                    phaseMarginDeg = 180 + phaseAtCrossover; // 相位富裕度 = 180° + 相位（负值）
                    break;
                }
            }
            
            // 计算-3dB带宽（截止频率）
            let bandwidth = null;
            
            // 计算-3dB点（相对于DC增益）
            const target3dB = dcGain - 3;
            
            for (let i = 0; i < magData.length - 1; i++) {
                if (magData[i] >= target3dB && magData[i+1] <= target3dB) {
                    // 线性插值找到-3dB交叉点
                    const t = (target3dB - magData[i]) / (magData[i+1] - magData[i]);
                    bandwidth = freqData[i] * (1-t) + freqData[i+1] * t;
                    break;
                }
            }
            
            // 显示相位富裕度和带宽信息
            const infoContainer = document.createElement('div');
            infoContainer.style.textAlign = 'center';
            infoContainer.style.marginTop = '10px';
            infoContainer.style.padding = '10px';
            infoContainer.style.backgroundColor = '#f8f9fa';
            infoContainer.style.borderRadius = '4px';
            infoContainer.id = 'phase-margin-info';
            
            let infoHTML = '';
            
            if (phaseMarginDeg !== null) {
                infoHTML += `<div><strong>相位富裕度:</strong> ${phaseMarginDeg.toFixed(2)}° (增益交叉频率: ${crossoverFreq.toFixed(2)} rad/s)</div>`;
            } else {
                infoHTML += '<div><strong>相位富裕度:</strong> 无法计算 (系统可能不会穿越0dB)</div>';
            }
            
            if (bandwidth !== null) {
                infoHTML += `<div><strong style="color: rgb(155, 89, 182);">截止频率:</strong> <span style="color: rgb(155, 89, 182); font-weight: bold;">${bandwidth.toFixed(2)} rad/s</span> (-3dB点，从${dcGain.toFixed(2)}dB下降)</div>`;
            } else {
                infoHTML += '<div><strong>截止频率:</strong> 无法计算</div>';
            }
            
            infoContainer.innerHTML = infoHTML;
            
            // 移除之前的信息（如果有）
            const existingInfo = document.getElementById('phase-margin-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            document.getElementById('frequency-domain').appendChild(infoContainer);
            
            // 绘制标记和注解
            setTimeout(() => {
                const chart = bodeCombinedChart;
                const ctx = chart.ctx;
                const xScale = chart.scales.x;
                const yScaleMag = chart.scales['y-magnitude'];
                const yScalePhase = chart.scales['y-phase'];
                
                ctx.save();
                
                // 绘制相位富裕度标记
                if (phaseMarginDeg !== null && crossoverFreq !== null) {
                    const x = xScale.getPixelForValue(crossoverFreq);
                    const y1 = yScalePhase.getPixelForValue(-180);
                    const y2 = yScalePhase.getPixelForValue(-180 + phaseMarginDeg);
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y1);
                    ctx.lineTo(x, y2);
                    ctx.strokeStyle = 'rgba(231, 76, 60, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 相位富裕度文本
                    ctx.font = '12px Arial';
                    ctx.fillStyle = 'rgba(231, 76, 60, 1)';
                    ctx.textAlign = 'center';
                    ctx.fillText('相位富裕度', x, (y1 + y2) / 2 - 10);
                    ctx.fillText(`${phaseMarginDeg.toFixed(1)}°`, x, (y1 + y2) / 2 + 10);
                }
                
                // 绘制-3dB带宽标记
                if (bandwidth !== null) {
                    const x = xScale.getPixelForValue(bandwidth);
                    const y = yScaleMag.getPixelForValue(target3dB);
                    
                    // 画大一点的圆点标记-3dB点
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(155, 89, 182, 0.8)';
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(142, 68, 173, 1)';
                    ctx.stroke();
                    
                    // 添加脉动效果
                    const pulseSize = 15;
                    ctx.beginPath();
                    ctx.arc(x, y, pulseSize, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(155, 89, 182, 0.3)';
                    ctx.fill();
                    
                    // 从-3dB点画垂直线到x轴
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, yScaleMag.getPixelForValue(yScaleMag.min));
                    ctx.strokeStyle = 'rgba(155, 89, 182, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    
                    // -3dB带宽文本 - 让字体更大更明显
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = 'rgba(142, 68, 173, 1)';
                    ctx.textAlign = 'center';
                    ctx.setLineDash([]);
                    ctx.fillText('-3dB点', x, y - 25);
                    ctx.fillText(`${bandwidth.toFixed(1)} rad/s`, x, yScaleMag.getPixelForValue(yScaleMag.min) + 30);
                }
                
                ctx.restore();
            }, 100);
        }
        
        // 更新物理系统动画
        let animationId;
        let startTime;
        let previousPosition = 0;
        
        function updateAnimation() {
            if (!stepInput) {
                cancelAnimationFrame(animationId);
                return;
            }
            
            const currentTime = performance.now();
            const elapsedTime = (currentTime - startTime) / 1000;  // 转换为秒
            
            // 计算系统参数
            const wn = Math.sqrt(springK / mass);  // 自然频率
            const zeta = damping / (2 * Math.sqrt(mass * springK));  // 阻尼比
            
            // 计算阶跃响应
            let position;
            if (zeta < 1) {  // 欠阻尼
                const wd = wn * Math.sqrt(1 - zeta * zeta);  // 阻尼振荡频率
                position = 1 - (Math.exp(-zeta * wn * elapsedTime) / Math.sqrt(1 - zeta * zeta)) * 
                    Math.sin(wd * elapsedTime + Math.atan(Math.sqrt(1 - zeta * zeta) / zeta));
            } else if (zeta === 1) {  // 临界阻尼
                position = 1 - Math.exp(-wn * elapsedTime) * (1 + wn * elapsedTime);
            } else {  // 过阻尼
                const p1 = -wn * (zeta + Math.sqrt(zeta * zeta - 1));
                const p2 = -wn * (zeta - Math.sqrt(zeta * zeta - 1));
                position = 1 + (p2 * Math.exp(p1 * elapsedTime) - p1 * Math.exp(p2 * elapsedTime)) / (p2 - p1);
            }
            
            // 为动画设置合适的缩放
            const scaleFactor = 50;  // 调整以适应动画区域
            const displacement = position * scaleFactor;
            
            // 更新质量位置
            massElement.style.transform = `translateX(${displacement}px)`;
            
            // 更新弹簧长度
            springElement.style.width = `${80 + displacement}px`;
            
            // 更新阻尼器位置
            damperElement.style.transform = `translateX(${displacement}px)`;
            
            // 速度视觉反馈（通过颜色）
            const velocity = (displacement - previousPosition) * 60;  // 近似速度
            previousPosition = displacement;
            
            // 速度越大，颜色越偏向红色
            const velocityColor = Math.abs(velocity) * 5;
            const r = Math.min(255, 231 + velocityColor);
            const g = Math.max(0, 76 - velocityColor);
            const b = Math.max(0, 60 - velocityColor);
            massElement.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            
            animationId = requestAnimationFrame(updateAnimation);
        }
        
        // 开始阶跃响应动画
        function startStepResponse() {
            stepInput = true;
            forceArrow.style.display = 'block';
            startTime = performance.now();
            previousPosition = 0;
            
            // 重置元素位置
            massElement.style.transform = 'translateX(0)';
            springElement.style.width = '80px';
            damperElement.style.transform = 'translateX(0)';
            
            cancelAnimationFrame(animationId);
            animationId = requestAnimationFrame(updateAnimation);
        }
        
        // 更新所有可视化
        function updateVisualizations() {
            updateEquations();
            updateTimeResponse();
            updateBodePlot();
            updatePolePlot();
        }
        
        // 滑块事件监听器
        massSlider.addEventListener('input', function() {
            mass = parseFloat(this.value);
            massValue.textContent = `${mass} kg`;
            updateVisualizations();
        });
        
        dampingSlider.addEventListener('input', function() {
            damping = parseFloat(this.value);
            dampingValue.textContent = `${damping} N·s/m`;
            updateVisualizations();
        });
        
        springSlider.addEventListener('input', function() {
            springK = parseFloat(this.value);
            springValue.textContent = `${springK} N/m`;
            updateVisualizations();
        });
        
        // 重置按钮
        resetButton.addEventListener('click', function() {
            mass = 1;
            damping = 2;
            springK = 10;
            
            massSlider.value = mass;
            dampingSlider.value = damping;
            springSlider.value = springK;
            
            massValue.textContent = `${mass} kg`;
            dampingValue.textContent = `${damping} N·s/m`;
            springValue.textContent = `${springK} N/m`;
            
            stepInput = false;
            forceArrow.style.display = 'none';
            
            // 重置元素位置
            massElement.style.transform = 'translateX(0)';
            springElement.style.width = '80px';
            damperElement.style.transform = 'translateX(0)';
            
            updateVisualizations();
        });
        
        // 阶跃输入按钮
        stepInputButton.addEventListener('click', startStepResponse);
        
        // 选项卡切换
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });
        
        // 初始化
        window.addEventListener('load', function() {
            initCharts();
            updateVisualizations();
            renderLatexFormulas();
        });
    </script>
</body>
</html>
